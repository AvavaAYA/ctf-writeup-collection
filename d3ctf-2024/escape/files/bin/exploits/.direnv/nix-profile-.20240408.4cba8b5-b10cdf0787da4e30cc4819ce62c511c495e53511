{
  "bashFunctions": {
    "_accumFlagsArray":" \n    local name;\n    if [ -n \"$__structuredAttrs\" ]; then\n        for name in \"$@\";\n        do\n            local -n nameref=\"$name\";\n            flagsArray+=(${nameref+\"${nameref[@]}\"});\n        done;\n    else\n        for name in \"$@\";\n        do\n            local -n nameref=\"$name\";\n            case \"$name\" in \n                *Array)\n                    flagsArray+=(${nameref+\"${nameref[@]}\"})\n                ;;\n                *)\n                    flagsArray+=(${nameref-})\n                ;;\n            esac;\n        done;\n    fi\n",
    "_activatePkgs":" \n    local hostOffset targetOffset;\n    local pkg;\n    for hostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local pkgsVar=\"${pkgAccumVarVars[hostOffset + 1]}\";\n        for targetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( hostOffset <= targetOffset )) || continue;\n            local pkgsRef=\"${pkgsVar}[$targetOffset - $hostOffset]\";\n            local pkgsSlice=\"${!pkgsRef}[@]\";\n            for pkg in ${!pkgsSlice+\"${!pkgsSlice}\"};\n            do\n                activatePackage \"$pkg\" \"$hostOffset\" \"$targetOffset\";\n            done;\n        done;\n    done\n",
    "_addRpathPrefix":" \n    if [ \"${NIX_NO_SELF_RPATH:-0}\" != 1 ]; then\n        export NIX_LDFLAGS=\"-rpath $1/lib ${NIX_LDFLAGS-}\";\n    fi\n",
    "_addToEnv":" \n    local depHostOffset depTargetOffset;\n    local pkg;\n    for depHostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local hookVar=\"${pkgHookVarVars[depHostOffset + 1]}\";\n        local pkgsVar=\"${pkgAccumVarVars[depHostOffset + 1]}\";\n        for depTargetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( depHostOffset <= depTargetOffset )) || continue;\n            local hookRef=\"${hookVar}[$depTargetOffset - $depHostOffset]\";\n            if [[ -z \"${strictDeps-}\" ]]; then\n                local visitedPkgs=\"\";\n                for pkg in \"${pkgsBuildBuild[@]}\" \"${pkgsBuildHost[@]}\" \"${pkgsBuildTarget[@]}\" \"${pkgsHostHost[@]}\" \"${pkgsHostTarget[@]}\" \"${pkgsTargetTarget[@]}\";\n                do\n                    if [[ \"$visitedPkgs\" = *\"$pkg\"* ]]; then\n                        continue;\n                    fi;\n                    runHook \"${!hookRef}\" \"$pkg\";\n                    visitedPkgs+=\" $pkg\";\n                done;\n            else\n                local pkgsRef=\"${pkgsVar}[$depTargetOffset - $depHostOffset]\";\n                local pkgsSlice=\"${!pkgsRef}[@]\";\n                for pkg in ${!pkgsSlice+\"${!pkgsSlice}\"};\n                do\n                    runHook \"${!hookRef}\" \"$pkg\";\n                done;\n            fi;\n        done;\n    done\n",
    "_allFlags":" \n    export system pname name version;\n    for varName in $(awk 'BEGIN { for (v in ENVIRON) if (v ~ /^[a-z][a-zA-Z0-9_]*$/) print v }');\n    do\n        if (( \"${NIX_DEBUG:-0}\" >= 1 )); then\n            printf \"@%s@ -> %q\\n\" \"${varName}\" \"${!varName}\" 1>&2;\n        fi;\n        args+=(\"--subst-var\" \"$varName\");\n    done\n",
    "_assignFirst":" \n    local varName=\"$1\";\n    local _var;\n    local REMOVE=REMOVE;\n    shift;\n    for _var in \"$@\";\n    do\n        if [ -n \"${!_var-}\" ]; then\n            eval \"${varName}\"=\"${_var}\";\n            return;\n        fi;\n    done;\n    echo;\n    echo \"error: _assignFirst: could not find a non-empty variable whose name to assign to ${varName}.\";\n    echo \"       The following variables were all unset or empty:\";\n    echo \"           $*\";\n    if [ -z \"${out:-}\" ]; then\n        echo '       If you do not want an \"out\" output in your derivation, make sure to define';\n        echo '       the other specific required outputs. This can be achieved by picking one';\n        echo \"       of the above as an output.\";\n        echo '       You do not have to remove \"out\" if you want to have a different default';\n        echo '       output, because the first output is taken as a default.';\n        echo;\n    fi;\n    return 1\n",
    "_callImplicitHook":" \n    local def=\"$1\";\n    local hookName=\"$2\";\n    if declare -F \"$hookName\" > /dev/null; then\n        \"$hookName\";\n    else\n        if type -p \"$hookName\" > /dev/null; then\n            source \"$hookName\";\n        else\n            if [ -n \"${!hookName:-}\" ]; then\n                eval \"${!hookName}\";\n            else\n                return \"$def\";\n            fi;\n        fi;\n    fi\n",
    "_defaultUnpack":" \n    local fn=\"$1\";\n    local destination;\n    if [ -d \"$fn\" ]; then\n        destination=\"$(stripHash \"$fn\")\";\n        if [ -e \"$destination\" ]; then\n            echo \"Cannot copy $fn to $destination: destination already exists!\";\n            echo \"Did you specify two \\\"srcs\\\" with the same \\\"name\\\"?\";\n            return 1;\n        fi;\n        cp -pr --reflink=auto -- \"$fn\" \"$destination\";\n    else\n        case \"$fn\" in \n            *.tar.xz | *.tar.lzma | *.txz)\n                ( XZ_OPT=\"--threads=$NIX_BUILD_CORES\" xz -d < \"$fn\";\n                true ) | tar xf - --warning=no-timestamp\n            ;;\n            *.tar | *.tar.* | *.tgz | *.tbz2 | *.tbz)\n                tar xf \"$fn\" --warning=no-timestamp\n            ;;\n            *)\n                return 1\n            ;;\n        esac;\n    fi\n",
    "_doStrip":" \n    local -ra flags=(dontStripHost dontStripTarget);\n    local -ra debugDirs=(stripDebugList stripDebugListTarget);\n    local -ra allDirs=(stripAllList stripAllListTarget);\n    local -ra stripCmds=(STRIP STRIP_FOR_TARGET);\n    local -ra ranlibCmds=(RANLIB RANLIB_FOR_TARGET);\n    stripDebugList=${stripDebugList[*]:-lib lib32 lib64 libexec bin sbin};\n    stripDebugListTarget=${stripDebugListTarget[*]:-};\n    stripAllList=${stripAllList[*]:-};\n    stripAllListTarget=${stripAllListTarget[*]:-};\n    local i;\n    for i in ${!stripCmds[@]};\n    do\n        local -n flag=\"${flags[$i]}\";\n        local -n debugDirList=\"${debugDirs[$i]}\";\n        local -n allDirList=\"${allDirs[$i]}\";\n        local -n stripCmd=\"${stripCmds[$i]}\";\n        local -n ranlibCmd=\"${ranlibCmds[$i]}\";\n        if [[ -n \"${dontStrip-}\" || -n \"${flag-}\" ]] || ! type -f \"${stripCmd-}\" 2> /dev/null 1>&2; then\n            continue;\n        fi;\n        stripDirs \"$stripCmd\" \"$ranlibCmd\" \"$debugDirList\" \"${stripDebugFlags[*]:--S -p}\";\n        stripDirs \"$stripCmd\" \"$ranlibCmd\" \"$allDirList\" \"${stripAllFlags[*]:--s -p}\";\n    done\n",
    "_eval":" \n    if declare -F \"$1\" > /dev/null 2>&1; then\n        \"$@\";\n    else\n        eval \"$1\";\n    fi\n",
    "_makeSymlinksRelative":" \n    local symlinkTarget;\n    if [ \"${dontRewriteSymlinks-}\" ] || [ ! -e \"$prefix\" ]; then\n        return;\n    fi;\n    while IFS= read -r -d '' f; do\n        symlinkTarget=$(readlink \"$f\");\n        if [[ \"$symlinkTarget\"/ != \"$prefix\"/* ]]; then\n            continue;\n        fi;\n        if [ ! -e \"$symlinkTarget\" ]; then\n            echo \"the symlink $f is broken, it points to $symlinkTarget (which is missing)\";\n        fi;\n        echo \"rewriting symlink $f to be relative to $prefix\";\n        ln -snrf \"$symlinkTarget\" \"$f\";\n    done < <(find $prefix -type l -print0)\n",
    "_makeSymlinksRelativeInAllOutputs":" \n    local output;\n    for output in $(getAllOutputNames);\n    do\n        prefix=\"${!output}\" _makeSymlinksRelative;\n    done\n",
    "_moveLib64":" \n    if [ \"${dontMoveLib64-}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"$prefix/lib64\" -o -L \"$prefix/lib64\" ]; then\n        return;\n    fi;\n    echo \"moving $prefix/lib64/* to $prefix/lib\";\n    mkdir -p $prefix/lib;\n    shopt -s dotglob;\n    for i in $prefix/lib64/*;\n    do\n        mv --no-clobber \"$i\" $prefix/lib;\n    done;\n    shopt -u dotglob;\n    rmdir $prefix/lib64;\n    ln -s lib $prefix/lib64\n",
    "_moveSbin":" \n    if [ \"${dontMoveSbin-}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"$prefix/sbin\" -o -L \"$prefix/sbin\" ]; then\n        return;\n    fi;\n    echo \"moving $prefix/sbin/* to $prefix/bin\";\n    mkdir -p $prefix/bin;\n    shopt -s dotglob;\n    for i in $prefix/sbin/*;\n    do\n        mv \"$i\" $prefix/bin;\n    done;\n    shopt -u dotglob;\n    rmdir $prefix/sbin;\n    ln -s bin $prefix/sbin\n",
    "_moveSystemdUserUnits":" \n    if [ \"${dontMoveSystemdUserUnits:-0}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"${prefix:?}/lib/systemd/user\" ]; then\n        return;\n    fi;\n    local source=\"$prefix/lib/systemd/user\";\n    local target=\"$prefix/share/systemd/user\";\n    echo \"moving $source/* to $target\";\n    mkdir -p \"$target\";\n    ( shopt -s dotglob;\n    for i in \"$source\"/*;\n    do\n        mv \"$i\" \"$target\";\n    done );\n    rmdir \"$source\";\n    ln -s \"$target\" \"$source\"\n",
    "_moveToShare":" \n    if [ -n \"$__structuredAttrs\" ]; then\n        if [ -z \"${forceShare-}\" ]; then\n            forceShare=(man doc info);\n        fi;\n    else\n        forceShare=(${forceShare:-man doc info});\n    fi;\n    if [[ -z \"$out\" ]]; then\n        return;\n    fi;\n    for d in \"${forceShare[@]}\";\n    do\n        if [ -d \"$out/$d\" ]; then\n            if [ -d \"$out/share/$d\" ]; then\n                echo \"both $d/ and share/$d/ exist!\";\n            else\n                echo \"moving $out/$d to $out/share/$d\";\n                mkdir -p $out/share;\n                mv $out/$d $out/share/;\n            fi;\n        fi;\n    done\n",
    "_multioutConfig":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ] || [ -z \"${setOutputFlags-1}\" ]; then\n        return;\n    fi;\n    if [ -z \"${shareDocName:-}\" ]; then\n        local confScript=\"${configureScript:-}\";\n        if [ -z \"$confScript\" ] && [ -x ./configure ]; then\n            confScript=./configure;\n        fi;\n        if [ -f \"$confScript\" ]; then\n            local shareDocName=\"$(sed -n \"s/^PACKAGE_TARNAME='\\(.*\\)'$/\\1/p\" < \"$confScript\")\";\n        fi;\n        if [ -z \"$shareDocName\" ] || echo \"$shareDocName\" | grep -q '[^a-zA-Z0-9_-]'; then\n            shareDocName=\"$(echo \"$name\" | sed 's/-[^a-zA-Z].*//')\";\n        fi;\n    fi;\n    prependToVar configureFlags --bindir=\"${!outputBin}\"/bin --sbindir=\"${!outputBin}\"/sbin --includedir=\"${!outputInclude}\"/include --oldincludedir=\"${!outputInclude}\"/include --mandir=\"${!outputMan}\"/share/man --infodir=\"${!outputInfo}\"/share/info --docdir=\"${!outputDoc}\"/share/doc/\"${shareDocName}\" --libdir=\"${!outputLib}\"/lib --libexecdir=\"${!outputLib}\"/libexec --localedir=\"${!outputLib}\"/share/locale;\n    prependToVar installFlags pkgconfigdir=\"${!outputDev}\"/lib/pkgconfig m4datadir=\"${!outputDev}\"/share/aclocal aclocaldir=\"${!outputDev}\"/share/aclocal\n",
    "_multioutDevs":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ] || [ -z \"${moveToDev-1}\" ]; then\n        return;\n    fi;\n    moveToOutput include \"${!outputInclude}\";\n    moveToOutput lib/pkgconfig \"${!outputDev}\";\n    moveToOutput share/pkgconfig \"${!outputDev}\";\n    moveToOutput lib/cmake \"${!outputDev}\";\n    moveToOutput share/aclocal \"${!outputDev}\";\n    for f in \"${!outputDev}\"/{lib,share}/pkgconfig/*.pc;\n    do\n        echo \"Patching '$f' includedir to output ${!outputInclude}\";\n        sed -i \"/^includedir=/s,=\\${prefix},=${!outputInclude},\" \"$f\";\n    done\n",
    "_multioutDocs":" \n    local REMOVE=REMOVE;\n    moveToOutput share/info \"${!outputInfo}\";\n    moveToOutput share/doc \"${!outputDoc}\";\n    moveToOutput share/gtk-doc \"${!outputDevdoc}\";\n    moveToOutput share/devhelp/books \"${!outputDevdoc}\";\n    moveToOutput share/man \"${!outputMan}\";\n    moveToOutput share/man/man3 \"${!outputDevman}\"\n",
    "_multioutPropagateDev":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ]; then\n        return;\n    fi;\n    local outputFirst;\n    for outputFirst in $(getAllOutputNames);\n    do\n        break;\n    done;\n    local propagaterOutput=\"$outputDev\";\n    if [ -z \"$propagaterOutput\" ]; then\n        propagaterOutput=\"$outputFirst\";\n    fi;\n    if [ -z \"${propagatedBuildOutputs+1}\" ]; then\n        local po_dirty=\"$outputBin $outputInclude $outputLib\";\n        set +o pipefail;\n        propagatedBuildOutputs=`echo \"$po_dirty\"             | tr -s ' ' '\\n' | grep -v -F \"$propagaterOutput\"             | sort -u | tr '\\n' ' ' `;\n        set -o pipefail;\n    fi;\n    if [ -z \"$propagatedBuildOutputs\" ]; then\n        return;\n    fi;\n    mkdir -p \"${!propagaterOutput}\"/nix-support;\n    for output in $propagatedBuildOutputs;\n    do\n        echo -n \" ${!output}\" >> \"${!propagaterOutput}\"/nix-support/propagated-build-inputs;\n    done\n",
    "_overrideFirst":" \n    if [ -z \"${!1-}\" ]; then\n        _assignFirst \"$@\";\n    fi\n",
    "_pruneLibtoolFiles":" \n    if [ \"${dontPruneLibtoolFiles-}\" ] || [ ! -e \"$prefix\" ]; then\n        return;\n    fi;\n    find \"$prefix\" -type f -name '*.la' -exec grep -q '^# Generated by .*libtool' {} \\; -exec grep -q \"^old_library=''\" {} \\; -exec sed -i {} -e \"/^dependency_libs='[^']/ c dependency_libs='' #pruned\" \\;\n",
    "_updateSourceDateEpochFromSourceRoot":" \n    if [ -n \"$sourceRoot\" ]; then\n        updateSourceDateEpoch \"$sourceRoot\";\n    fi\n",
    "activatePackage":" \n    local pkg=\"$1\";\n    local -r hostOffset=\"$2\";\n    local -r targetOffset=\"$3\";\n    (( hostOffset <= targetOffset )) || exit 1;\n    if [ -f \"$pkg\" ]; then\n        source \"$pkg\";\n    fi;\n    if [[ -z \"${strictDeps-}\" || \"$hostOffset\" -le -1 ]]; then\n        addToSearchPath _PATH \"$pkg/bin\";\n    fi;\n    if (( hostOffset <= -1 )); then\n        addToSearchPath _XDG_DATA_DIRS \"$pkg/share\";\n    fi;\n    if [[ \"$hostOffset\" -eq 0 && -d \"$pkg/bin\" ]]; then\n        addToSearchPath _HOST_PATH \"$pkg/bin\";\n    fi;\n    if [[ -f \"$pkg/nix-support/setup-hook\" ]]; then\n        source \"$pkg/nix-support/setup-hook\";\n    fi\n",
    "addEnvHooks":" \n    local depHostOffset=\"$1\";\n    shift;\n    local pkgHookVarsSlice=\"${pkgHookVarVars[$depHostOffset + 1]}[@]\";\n    local pkgHookVar;\n    for pkgHookVar in \"${!pkgHookVarsSlice}\";\n    do\n        eval \"${pkgHookVar}s\"'+=(\"$@\")';\n    done\n",
    "addToSearchPath":" \n    addToSearchPathWithCustomDelimiter \":\" \"$@\"\n",
    "addToSearchPathWithCustomDelimiter":" \n    local delimiter=\"$1\";\n    local varName=\"$2\";\n    local dir=\"$3\";\n    if [[ -d \"$dir\" && \"${!varName:+${delimiter}${!varName}${delimiter}}\" != *\"${delimiter}${dir}${delimiter}\"* ]]; then\n        export \"${varName}=${!varName:+${!varName}${delimiter}}${dir}\";\n    fi\n",
    "appendToVar":" \n    local -n nameref=\"$1\";\n    local useArray type;\n    if [ -n \"$__structuredAttrs\" ]; then\n        useArray=true;\n    else\n        useArray=false;\n    fi;\n    if declare -p \"$1\" 2> /dev/null | grep -q '^'; then\n        type=\"$(declare -p \"$1\")\";\n        if [[ \"$type\" =~ \"declare -A\" ]]; then\n            echo \"appendToVar(): ERROR: trying to use appendToVar on an associative array, use variable+=([\\\"X\\\"]=\\\"Y\\\") instead.\" 1>&2;\n            return 1;\n        else\n            if [[ \"$type\" =~ \"declare -a\" ]]; then\n                useArray=true;\n            else\n                useArray=false;\n            fi;\n        fi;\n    fi;\n    shift;\n    if $useArray; then\n        nameref=(${nameref+\"${nameref[@]}\"} \"$@\");\n    else\n        nameref=\"${nameref-} $*\";\n    fi\n",
    "auditTmpdir":" \n    local dir=\"$1\";\n    [ -e \"$dir\" ] || return 0;\n    echo \"checking for references to $TMPDIR/ in $dir...\";\n    local i;\n    find \"$dir\" -type f -print0 | while IFS= read -r -d '' i; do\n        if [[ \"$i\" =~ .build-id ]]; then\n            continue;\n        fi;\n        if isELF \"$i\"; then\n            if { \n                printf :;\n                patchelf --print-rpath \"$i\"\n            } | grep -q -F \":$TMPDIR/\"; then\n                echo \"RPATH of binary $i contains a forbidden reference to $TMPDIR/\";\n                exit 1;\n            fi;\n        fi;\n        if isScript \"$i\"; then\n            if [ -e \"$(dirname \"$i\")/.$(basename \"$i\")-wrapped\" ]; then\n                if grep -q -F \"$TMPDIR/\" \"$i\"; then\n                    echo \"wrapper script $i contains a forbidden reference to $TMPDIR/\";\n                    exit 1;\n                fi;\n            fi;\n        fi;\n    done\n",
    "bintoolsWrapper_addLDVars":" \n    local role_post;\n    getHostRoleEnvHook;\n    if [[ -d \"$1/lib64\" && ! -L \"$1/lib64\" ]]; then\n        export NIX_LDFLAGS${role_post}+=\" -L$1/lib64\";\n    fi;\n    if [[ -d \"$1/lib\" ]]; then\n        local -a glob=($1/lib/lib*);\n        if [ \"${#glob[*]}\" -gt 0 ]; then\n            export NIX_LDFLAGS${role_post}+=\" -L$1/lib\";\n        fi;\n    fi\n",
    "buildPhase":" \n    runHook preBuild;\n    if [[ -z \"${makeFlags-}\" && -z \"${makefile:-}\" && ! ( -e Makefile || -e makefile || -e GNUmakefile ) ]]; then\n        echo \"no Makefile or custom buildPhase, doing nothing\";\n    else\n        foundMakefile=1;\n        local flagsArray=(${enableParallelBuilding:+-j${NIX_BUILD_CORES}} SHELL=$SHELL);\n        _accumFlagsArray makeFlags makeFlagsArray buildFlags buildFlagsArray;\n        echoCmd 'build flags' \"${flagsArray[@]}\";\n        make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n        unset flagsArray;\n    fi;\n    runHook postBuild\n",
    "ccWrapper_addCVars":" \n    local role_post;\n    getHostRoleEnvHook;\n    if [ -d \"$1/include\" ]; then\n        export NIX_CFLAGS_COMPILE${role_post}+=\" -isystem $1/include\";\n    fi;\n    if [ -d \"$1/Library/Frameworks\" ]; then\n        export NIX_CFLAGS_COMPILE${role_post}+=\" -iframework $1/Library/Frameworks\";\n    fi\n",
    "checkPhase":" \n    runHook preCheck;\n    if [[ -z \"${foundMakefile:-}\" ]]; then\n        echo \"no Makefile or custom checkPhase, doing nothing\";\n        runHook postCheck;\n        return;\n    fi;\n    if [[ -z \"${checkTarget:-}\" ]]; then\n        if make -n ${makefile:+-f $makefile} check > /dev/null 2>&1; then\n            checkTarget=check;\n        else\n            if make -n ${makefile:+-f $makefile} test > /dev/null 2>&1; then\n                checkTarget=test;\n            fi;\n        fi;\n    fi;\n    if [[ -z \"${checkTarget:-}\" ]]; then\n        echo \"no check/test target in ${makefile:-Makefile}, doing nothing\";\n    else\n        local flagsArray=(${enableParallelChecking:+-j${NIX_BUILD_CORES}} SHELL=$SHELL);\n        _accumFlagsArray makeFlags makeFlagsArray;\n        if [ -n \"$__structuredAttrs\" ]; then\n            flagsArray+=(\"${checkFlags[@]:-VERBOSE=y}\");\n        else\n            flagsArray+=(${checkFlags:-VERBOSE=y});\n        fi;\n        _accumFlagsArray checkFlagsArray;\n        flagsArray+=(${checkTarget});\n        echoCmd 'check flags' \"${flagsArray[@]}\";\n        make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n        unset flagsArray;\n    fi;\n    runHook postCheck\n",
    "compressManPages":" \n    local dir=\"$1\";\n    if [ -L \"$dir\"/share ] || [ -L \"$dir\"/share/man ] || [ ! -d \"$dir/share/man\" ]; then\n        return;\n    fi;\n    echo \"gzipping man pages under $dir/share/man/\";\n    find \"$dir\"/share/man/ -type f -a '!' -regex '.*\\.\\(bz2\\|gz\\|xz\\)$' -print0 | while IFS= read -r -d '' f; do\n        if gzip -c -n \"$f\" > \"$f\".gz; then\n            rm \"$f\";\n        else\n            rm \"$f\".gz;\n        fi;\n    done;\n    find \"$dir\"/share/man/ -type l -a '!' -regex '.*\\.\\(bz2\\|gz\\|xz\\)$' -print0 | sort -z | while IFS= read -r -d '' f; do\n        local target;\n        target=\"$(readlink -f \"$f\")\";\n        if [ -f \"$target\".gz ]; then\n            ln -sf \"$target\".gz \"$f\".gz && rm \"$f\";\n        fi;\n    done\n",
    "configurePhase":" \n    runHook preConfigure;\n    : \"${configureScript=}\";\n    if [[ -z \"$configureScript\" && -x ./configure ]]; then\n        configureScript=./configure;\n    fi;\n    if [ -z \"${dontFixLibtool:-}\" ]; then\n        export lt_cv_deplibs_check_method=\"${lt_cv_deplibs_check_method-pass_all}\";\n        local i;\n        find . -iname \"ltmain.sh\" -print0 | while IFS='' read -r -d '' i; do\n            echo \"fixing libtool script $i\";\n            fixLibtool \"$i\";\n        done;\n        CONFIGURE_MTIME_REFERENCE=$(mktemp configure.mtime.reference.XXXXXX);\n        find . -executable -type f -name configure -exec grep -l 'GNU Libtool is free software; you can redistribute it and/or modify' {} \\; -exec touch -r {} \"$CONFIGURE_MTIME_REFERENCE\" \\; -exec sed -i s_/usr/bin/file_file_g {} \\; -exec touch -r \"$CONFIGURE_MTIME_REFERENCE\" {} \\;;\n        rm -f \"$CONFIGURE_MTIME_REFERENCE\";\n    fi;\n    if [[ -z \"${dontAddPrefix:-}\" && -n \"$prefix\" ]]; then\n        prependToVar configureFlags \"${prefixKey:---prefix=}$prefix\";\n    fi;\n    if [[ -f \"$configureScript\" ]]; then\n        if [ -z \"${dontAddDisableDepTrack:-}\" ]; then\n            if grep -q dependency-tracking \"$configureScript\"; then\n                prependToVar configureFlags --disable-dependency-tracking;\n            fi;\n        fi;\n        if [ -z \"${dontDisableStatic:-}\" ]; then\n            if grep -q enable-static \"$configureScript\"; then\n                prependToVar configureFlags --disable-static;\n            fi;\n        fi;\n        if [ -z \"${dontPatchShebangsInConfigure:-}\" ]; then\n            patchShebangs --build \"$configureScript\";\n        fi;\n    fi;\n    if [ -n \"$configureScript\" ]; then\n        local -a flagsArray;\n        _accumFlagsArray configureFlags configureFlagsArray;\n        echoCmd 'configure flags' \"${flagsArray[@]}\";\n        $configureScript \"${flagsArray[@]}\";\n        unset flagsArray;\n    else\n        echo \"no configure script, doing nothing\";\n    fi;\n    runHook postConfigure\n",
    "consumeEntire":" \n    if IFS='' read -r -d '' \"$1\"; then\n        echo \"consumeEntire(): ERROR: Input null bytes, won't process\" 1>&2;\n        return 1;\n    fi\n",
    "distPhase":" \n    runHook preDist;\n    local flagsArray=();\n    _accumFlagsArray distFlags distFlagsArray;\n    flagsArray+=(${distTarget:-dist});\n    echo 'dist flags: %q' \"${flagsArray[@]}\";\n    make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n    if [ \"${dontCopyDist:-0}\" != 1 ]; then\n        mkdir -p \"$out/tarballs\";\n        cp -pvd ${tarballs[*]:-*.tar.gz} \"$out/tarballs\";\n    fi;\n    runHook postDist\n",
    "dumpVars":" \n    if [ \"${noDumpEnvVars:-0}\" != 1 ]; then\n        export 2> /dev/null >| \"$NIX_BUILD_TOP/env-vars\" || true;\n    fi\n",
    "echoCmd":" \n    printf \"%s:\" \"$1\";\n    shift;\n    printf ' %q' \"$@\";\n    echo\n",
    "exitHandler":" \n    exitCode=\"$?\";\n    set +e;\n    if [ -n \"${showBuildStats:-}\" ]; then\n        read -r -d '' -a buildTimes < <(times);\n        echo \"build times:\";\n        echo \"user time for the shell             ${buildTimes[0]}\";\n        echo \"system time for the shell           ${buildTimes[1]}\";\n        echo \"user time for all child processes   ${buildTimes[2]}\";\n        echo \"system time for all child processes ${buildTimes[3]}\";\n    fi;\n    if (( \"$exitCode\" != 0 )); then\n        runHook failureHook;\n        if [ -n \"${succeedOnFailure:-}\" ]; then\n            echo \"build failed with exit code $exitCode (ignored)\";\n            mkdir -p \"$out/nix-support\";\n            printf \"%s\" \"$exitCode\" > \"$out/nix-support/failed\";\n            exit 0;\n        fi;\n    else\n        runHook exitHook;\n    fi;\n    return \"$exitCode\"\n",
    "findInputs":" \n    local -r pkg=\"$1\";\n    local -r hostOffset=\"$2\";\n    local -r targetOffset=\"$3\";\n    (( hostOffset <= targetOffset )) || exit 1;\n    local varVar=\"${pkgAccumVarVars[hostOffset + 1]}\";\n    local varRef=\"$varVar[$((targetOffset - hostOffset))]\";\n    local var=\"${!varRef}\";\n    unset -v varVar varRef;\n    local varSlice=\"$var[*]\";\n    case \"${!varSlice-}\" in \n        *\" $pkg \"*)\n            return 0\n        ;;\n    esac;\n    unset -v varSlice;\n    eval \"$var\"'+=(\"$pkg\")';\n    if ! [ -e \"$pkg\" ]; then\n        echo \"build input $pkg does not exist\" 1>&2;\n        exit 1;\n    fi;\n    function mapOffset () \n    { \n        local -r inputOffset=\"$1\";\n        local -n outputOffset=\"$2\";\n        if (( inputOffset <= 0 )); then\n            outputOffset=$((inputOffset + hostOffset));\n        else\n            outputOffset=$((inputOffset - 1 + targetOffset));\n        fi\n    };\n    local relHostOffset;\n    for relHostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local files=\"${propagatedDepFilesVars[relHostOffset + 1]}\";\n        local hostOffsetNext;\n        mapOffset \"$relHostOffset\" hostOffsetNext;\n        (( -1 <= hostOffsetNext && hostOffsetNext <= 1 )) || continue;\n        local relTargetOffset;\n        for relTargetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( \"$relHostOffset\" <= \"$relTargetOffset\" )) || continue;\n            local fileRef=\"${files}[$relTargetOffset - $relHostOffset]\";\n            local file=\"${!fileRef}\";\n            unset -v fileRef;\n            local targetOffsetNext;\n            mapOffset \"$relTargetOffset\" targetOffsetNext;\n            (( -1 <= hostOffsetNext && hostOffsetNext <= 1 )) || continue;\n            [[ -f \"$pkg/nix-support/$file\" ]] || continue;\n            local pkgNext;\n            read -r -d '' pkgNext < \"$pkg/nix-support/$file\" || true;\n            for pkgNext in $pkgNext;\n            do\n                findInputs \"$pkgNext\" \"$hostOffsetNext\" \"$targetOffsetNext\";\n            done;\n        done;\n    done\n",
    "fixLibtool":" \n    local search_path;\n    for flag in $NIX_LDFLAGS;\n    do\n        case $flag in \n            -L*)\n                search_path+=\" ${flag#-L}\"\n            ;;\n        esac;\n    done;\n    sed -i \"$1\" -e \"s^eval \\(sys_lib_search_path=\\).*^\\1'${search_path:-}'^\" -e 's^eval sys_lib_.+search_path=.*^^'\n",
    "fixupPhase":" \n    local output;\n    for output in $(getAllOutputNames);\n    do\n        if [ -e \"${!output}\" ]; then\n            chmod -R u+w \"${!output}\";\n        fi;\n    done;\n    runHook preFixup;\n    local output;\n    for output in $(getAllOutputNames);\n    do\n        prefix=\"${!output}\" runHook fixupOutput;\n    done;\n    recordPropagatedDependencies;\n    if [ -n \"${setupHook:-}\" ]; then\n        mkdir -p \"${!outputDev}/nix-support\";\n        substituteAll \"$setupHook\" \"${!outputDev}/nix-support/setup-hook\";\n    fi;\n    if [ -n \"${setupHooks:-}\" ]; then\n        mkdir -p \"${!outputDev}/nix-support\";\n        local hook;\n        for hook in ${setupHooks[@]};\n        do\n            local content;\n            consumeEntire content < \"$hook\";\n            substituteAllStream content \"file '$hook'\" >> \"${!outputDev}/nix-support/setup-hook\";\n            unset -v content;\n        done;\n        unset -v hook;\n    fi;\n    if [ -n \"${propagatedUserEnvPkgs:-}\" ]; then\n        mkdir -p \"${!outputBin}/nix-support\";\n        printWords $propagatedUserEnvPkgs > \"${!outputBin}/nix-support/propagated-user-env-packages\";\n    fi;\n    runHook postFixup\n",
    "genericBuild":" \n    export GZIP_NO_TIMESTAMPS=1;\n    if [ -f \"${buildCommandPath:-}\" ]; then\n        source \"$buildCommandPath\";\n        return;\n    fi;\n    if [ -n \"${buildCommand:-}\" ]; then\n        eval \"$buildCommand\";\n        return;\n    fi;\n    if [ -z \"${phases[*]:-}\" ]; then\n        phases=\"${prePhases[*]:-} unpackPhase patchPhase ${preConfigurePhases[*]:-}             configurePhase ${preBuildPhases[*]:-} buildPhase checkPhase             ${preInstallPhases[*]:-} installPhase ${preFixupPhases[*]:-} fixupPhase installCheckPhase             ${preDistPhases[*]:-} distPhase ${postPhases[*]:-}\";\n    fi;\n    for curPhase in ${phases[*]};\n    do\n        runPhase \"$curPhase\";\n    done\n",
    "getAllOutputNames":" \n    if [ -n \"$__structuredAttrs\" ]; then\n        echo \"${!outputs[*]}\";\n    else\n        echo \"$outputs\";\n    fi\n",
    "getHostRole":" \n    getRole \"$hostOffset\"\n",
    "getHostRoleEnvHook":" \n    getRole \"$depHostOffset\"\n",
    "getRole":" \n    case $1 in \n        -1)\n            role_post='_FOR_BUILD'\n        ;;\n        0)\n            role_post=''\n        ;;\n        1)\n            role_post='_FOR_TARGET'\n        ;;\n        *)\n            echo \"binutils-wrapper-2.41: used as improper sort of dependency\" 1>&2;\n            return 1\n        ;;\n    esac\n",
    "getTargetRole":" \n    getRole \"$targetOffset\"\n",
    "getTargetRoleEnvHook":" \n    getRole \"$depTargetOffset\"\n",
    "getTargetRoleWrapper":" \n    case $targetOffset in \n        -1)\n            export NIX_BINTOOLS_WRAPPER_TARGET_BUILD_x86_64_unknown_linux_gnu=1\n        ;;\n        0)\n            export NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu=1\n        ;;\n        1)\n            export NIX_BINTOOLS_WRAPPER_TARGET_TARGET_x86_64_unknown_linux_gnu=1\n        ;;\n        *)\n            echo \"binutils-wrapper-2.41: used as improper sort of dependency\" 1>&2;\n            return 1\n        ;;\n    esac\n",
    "installCheckPhase":" \n    runHook preInstallCheck;\n    if [[ -z \"${foundMakefile:-}\" ]]; then\n        echo \"no Makefile or custom installCheckPhase, doing nothing\";\n    else\n        if [[ -z \"${installCheckTarget:-}\" ]] && ! make -n ${makefile:+-f $makefile} \"${installCheckTarget:-installcheck}\" > /dev/null 2>&1; then\n            echo \"no installcheck target in ${makefile:-Makefile}, doing nothing\";\n        else\n            local flagsArray=(${enableParallelChecking:+-j${NIX_BUILD_CORES}} SHELL=$SHELL);\n            _accumFlagsArray makeFlags makeFlagsArray installCheckFlags installCheckFlagsArray;\n            flagsArray+=(${installCheckTarget:-installcheck});\n            echoCmd 'installcheck flags' \"${flagsArray[@]}\";\n            make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n            unset flagsArray;\n        fi;\n    fi;\n    runHook postInstallCheck\n",
    "installPhase":" \n    runHook preInstall;\n    if [[ -z \"${makeFlags-}\" && -z \"${makefile:-}\" && ! ( -e Makefile || -e makefile || -e GNUmakefile ) ]]; then\n        echo \"no Makefile or custom installPhase, doing nothing\";\n        runHook postInstall;\n        return;\n    else\n        foundMakefile=1;\n    fi;\n    if [ -n \"$prefix\" ]; then\n        mkdir -p \"$prefix\";\n    fi;\n    local flagsArray=(${enableParallelInstalling:+-j${NIX_BUILD_CORES}} SHELL=$SHELL);\n    _accumFlagsArray makeFlags makeFlagsArray installFlags installFlagsArray;\n    if [ -n \"$__structuredAttrs\" ]; then\n        flagsArray+=(\"${installTargets[@]:-install}\");\n    else\n        flagsArray+=(${installTargets:-install});\n    fi;\n    echoCmd 'install flags' \"${flagsArray[@]}\";\n    make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n    unset flagsArray;\n    runHook postInstall\n",
    "isELF":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 4 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [ \"$magic\" = 'ELF' ]; then\n        return 0;\n    else\n        return 1;\n    fi\n",
    "isMachO":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 4 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [[ \"$magic\" = $(echo -ne \"\\xfe\\xed\\xfa\\xcf\") || \"$magic\" = $(echo -ne \"\\xcf\\xfa\\xed\\xfe\") ]]; then\n        return 0;\n    else\n        if [[ \"$magic\" = $(echo -ne \"\\xfe\\xed\\xfa\\xce\") || \"$magic\" = $(echo -ne \"\\xce\\xfa\\xed\\xfe\") ]]; then\n            return 0;\n        else\n            if [[ \"$magic\" = $(echo -ne \"\\xca\\xfe\\xba\\xbe\") || \"$magic\" = $(echo -ne \"\\xbe\\xba\\xfe\\xca\") ]]; then\n                return 0;\n            else\n                return 1;\n            fi;\n        fi;\n    fi\n",
    "isScript":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 2 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [[ \"$magic\" =~ \\#! ]]; then\n        return 0;\n    else\n        return 1;\n    fi\n",
    "mapOffset":" \n    local -r inputOffset=\"$1\";\n    local -n outputOffset=\"$2\";\n    if (( inputOffset <= 0 )); then\n        outputOffset=$((inputOffset + hostOffset));\n    else\n        outputOffset=$((inputOffset - 1 + targetOffset));\n    fi\n",
    "moveToOutput":" \n    local patt=\"$1\";\n    local dstOut=\"$2\";\n    local output;\n    for output in $(getAllOutputNames);\n    do\n        if [ \"${!output}\" = \"$dstOut\" ]; then\n            continue;\n        fi;\n        local srcPath;\n        for srcPath in \"${!output}\"/$patt;\n        do\n            if [ ! -e \"$srcPath\" ] && [ ! -L \"$srcPath\" ]; then\n                continue;\n            fi;\n            if [ \"$dstOut\" = REMOVE ]; then\n                echo \"Removing $srcPath\";\n                rm -r \"$srcPath\";\n            else\n                local dstPath=\"$dstOut${srcPath#${!output}}\";\n                echo \"Moving $srcPath to $dstPath\";\n                if [ -d \"$dstPath\" ] && [ -d \"$srcPath\" ]; then\n                    rmdir \"$srcPath\" --ignore-fail-on-non-empty;\n                    if [ -d \"$srcPath\" ]; then\n                        mv -t \"$dstPath\" \"$srcPath\"/*;\n                        rmdir \"$srcPath\";\n                    fi;\n                else\n                    mkdir -p \"$(readlink -m \"$dstPath/..\")\";\n                    mv \"$srcPath\" \"$dstPath\";\n                fi;\n            fi;\n            local srcParent=\"$(readlink -m \"$srcPath/..\")\";\n            if [ -n \"$(find \"$srcParent\" -maxdepth 0 -type d -empty 2> /dev/null)\" ]; then\n                echo \"Removing empty $srcParent/ and (possibly) its parents\";\n                rmdir -p --ignore-fail-on-non-empty \"$srcParent\" 2> /dev/null || true;\n            fi;\n        done;\n    done\n",
    "patchELF":" \n    local dir=\"$1\";\n    [ -e \"$dir\" ] || return 0;\n    echo \"shrinking RPATHs of ELF executables and libraries in $dir\";\n    local i;\n    while IFS= read -r -d '' i; do\n        if [[ \"$i\" =~ .build-id ]]; then\n            continue;\n        fi;\n        if ! isELF \"$i\"; then\n            continue;\n        fi;\n        echo \"shrinking $i\";\n        patchelf --shrink-rpath \"$i\" || true;\n    done < <(find \"$dir\" -type f -print0)\n",
    "patchPhase":" \n    runHook prePatch;\n    local -a patchesArray;\n    if [ -n \"$__structuredAttrs\" ]; then\n        patchesArray=(${patches:+\"${patches[@]}\"});\n    else\n        patchesArray=(${patches:-});\n    fi;\n    for i in \"${patchesArray[@]}\";\n    do\n        echo \"applying patch $i\";\n        local uncompress=cat;\n        case \"$i\" in \n            *.gz)\n                uncompress=\"gzip -d\"\n            ;;\n            *.bz2)\n                uncompress=\"bzip2 -d\"\n            ;;\n            *.xz)\n                uncompress=\"xz -d\"\n            ;;\n            *.lzma)\n                uncompress=\"lzma -d\"\n            ;;\n        esac;\n        local -a flagsArray;\n        if [ -n \"$__structuredAttrs\" ]; then\n            flagsArray=(\"${patchFlags[@]:--p1}\");\n        else\n            flagsArray=(${patchFlags:--p1});\n        fi;\n        $uncompress < \"$i\" 2>&1 | patch \"${flagsArray[@]}\";\n    done;\n    runHook postPatch\n",
    "patchShebangs":" \n    local pathName;\n    local update;\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in \n            --host)\n                pathName=HOST_PATH;\n                shift\n            ;;\n            --build)\n                pathName=PATH;\n                shift\n            ;;\n            --update)\n                update=true;\n                shift\n            ;;\n            --)\n                shift;\n                break\n            ;;\n            -* | --*)\n                echo \"Unknown option $1 supplied to patchShebangs\" 1>&2;\n                return 1\n            ;;\n            *)\n                break\n            ;;\n        esac;\n    done;\n    echo \"patching script interpreter paths in $@\";\n    local f;\n    local oldPath;\n    local newPath;\n    local arg0;\n    local args;\n    local oldInterpreterLine;\n    local newInterpreterLine;\n    if [[ $# -eq 0 ]]; then\n        echo \"No arguments supplied to patchShebangs\" 1>&2;\n        return 0;\n    fi;\n    local f;\n    while IFS= read -r -d '' f; do\n        isScript \"$f\" || continue;\n        read -r oldInterpreterLine < \"$f\" || [ \"$oldInterpreterLine\" ];\n        read -r oldPath arg0 args <<< \"${oldInterpreterLine:2}\";\n        if [[ -z \"${pathName:-}\" ]]; then\n            if [[ -n $strictDeps && $f == \"$NIX_STORE\"* ]]; then\n                pathName=HOST_PATH;\n            else\n                pathName=PATH;\n            fi;\n        fi;\n        if [[ \"$oldPath\" == *\"/bin/env\" ]]; then\n            if [[ $arg0 == \"-S\" ]]; then\n                arg0=${args%% *};\n                args=${args#* };\n                newPath=\"$(PATH=\"${!pathName}\" command -v \"env\" || true)\";\n                args=\"-S $(PATH=\"${!pathName}\" command -v \"$arg0\" || true) $args\";\n            else\n                if [[ $arg0 == \"-\"* || $arg0 == *\"=\"* ]]; then\n                    echo \"$f: unsupported interpreter directive \\\"$oldInterpreterLine\\\" (set dontPatchShebangs=1 and handle shebang patching yourself)\" 1>&2;\n                    exit 1;\n                else\n                    newPath=\"$(PATH=\"${!pathName}\" command -v \"$arg0\" || true)\";\n                fi;\n            fi;\n        else\n            if [[ -z $oldPath ]]; then\n                oldPath=\"/bin/sh\";\n            fi;\n            newPath=\"$(PATH=\"${!pathName}\" command -v \"$(basename \"$oldPath\")\" || true)\";\n            args=\"$arg0 $args\";\n        fi;\n        newInterpreterLine=\"$newPath $args\";\n        newInterpreterLine=${newInterpreterLine%${newInterpreterLine##*[![:space:]]}};\n        if [[ -n \"$oldPath\" && ( \"$update\" == true || \"${oldPath:0:${#NIX_STORE}}\" != \"$NIX_STORE\" ) ]]; then\n            if [[ -n \"$newPath\" && \"$newPath\" != \"$oldPath\" ]]; then\n                echo \"$f: interpreter directive changed from \\\"$oldInterpreterLine\\\" to \\\"$newInterpreterLine\\\"\";\n                escapedInterpreterLine=${newInterpreterLine//\\\\/\\\\\\\\};\n                timestamp=$(stat --printf \"%y\" \"$f\");\n                sed -i -e \"1 s|.*|#\\!$escapedInterpreterLine|\" \"$f\";\n                touch --date \"$timestamp\" \"$f\";\n            fi;\n        fi;\n    done < <(find \"$@\" -type f -perm -0100 -print0)\n",
    "patchShebangsAuto":" \n    if [[ -z \"${dontPatchShebangs-}\" && -e \"$prefix\" ]]; then\n        if [[ \"$output\" != out && \"$output\" = \"$outputDev\" ]]; then\n            patchShebangs --build \"$prefix\";\n        else\n            patchShebangs --host \"$prefix\";\n        fi;\n    fi\n",
    "prependToVar":" \n    local -n nameref=\"$1\";\n    local useArray type;\n    if [ -n \"$__structuredAttrs\" ]; then\n        useArray=true;\n    else\n        useArray=false;\n    fi;\n    if declare -p \"$1\" 2> /dev/null | grep -q '^'; then\n        type=\"$(declare -p \"$1\")\";\n        if [[ \"$type\" =~ \"declare -A\" ]]; then\n            echo \"prependToVar(): ERROR: trying to use prependToVar on an associative array.\" 1>&2;\n            return 1;\n        else\n            if [[ \"$type\" =~ \"declare -a\" ]]; then\n                useArray=true;\n            else\n                useArray=false;\n            fi;\n        fi;\n    fi;\n    shift;\n    if $useArray; then\n        nameref=(\"$@\" ${nameref+\"${nameref[@]}\"});\n    else\n        nameref=\"$* ${nameref-}\";\n    fi\n",
    "printLines":" \n    (( \"$#\" > 0 )) || return 0;\n    printf '%s\\n' \"$@\"\n",
    "printWords":" \n    (( \"$#\" > 0 )) || return 0;\n    printf '%s ' \"$@\"\n",
    "recordPropagatedDependencies":" \n    declare -ra flatVars=(depsBuildBuildPropagated propagatedNativeBuildInputs depsBuildTargetPropagated depsHostHostPropagated propagatedBuildInputs depsTargetTargetPropagated);\n    declare -ra flatFiles=(\"${propagatedBuildDepFiles[@]}\" \"${propagatedHostDepFiles[@]}\" \"${propagatedTargetDepFiles[@]}\");\n    local propagatedInputsIndex;\n    for propagatedInputsIndex in \"${!flatVars[@]}\";\n    do\n        local propagatedInputsSlice=\"${flatVars[$propagatedInputsIndex]}[@]\";\n        local propagatedInputsFile=\"${flatFiles[$propagatedInputsIndex]}\";\n        [[ -n \"${!propagatedInputsSlice}\" ]] || continue;\n        mkdir -p \"${!outputDev}/nix-support\";\n        printWords ${!propagatedInputsSlice} > \"${!outputDev}/nix-support/$propagatedInputsFile\";\n    done\n",
    "runHook":" \n    local hookName=\"$1\";\n    shift;\n    local hooksSlice=\"${hookName%Hook}Hooks[@]\";\n    local hook;\n    for hook in \"_callImplicitHook 0 $hookName\" ${!hooksSlice+\"${!hooksSlice}\"};\n    do\n        _eval \"$hook\" \"$@\";\n    done;\n    return 0\n",
    "runOneHook":" \n    local hookName=\"$1\";\n    shift;\n    local hooksSlice=\"${hookName%Hook}Hooks[@]\";\n    local hook ret=1;\n    for hook in \"_callImplicitHook 1 $hookName\" ${!hooksSlice+\"${!hooksSlice}\"};\n    do\n        if _eval \"$hook\" \"$@\"; then\n            ret=0;\n            break;\n        fi;\n    done;\n    return \"$ret\"\n",
    "runPhase":" \n    local curPhase=\"$*\";\n    if [[ \"$curPhase\" = unpackPhase && -n \"${dontUnpack:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = patchPhase && -n \"${dontPatch:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = configurePhase && -n \"${dontConfigure:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = buildPhase && -n \"${dontBuild:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = checkPhase && -z \"${doCheck:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = installPhase && -n \"${dontInstall:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = fixupPhase && -n \"${dontFixup:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = installCheckPhase && -z \"${doInstallCheck:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = distPhase && -z \"${doDist:-}\" ]]; then\n        return;\n    fi;\n    if [[ -n $NIX_LOG_FD ]]; then\n        echo \"@nix { \\\"action\\\": \\\"setPhase\\\", \\\"phase\\\": \\\"$curPhase\\\" }\" >&\"$NIX_LOG_FD\";\n    fi;\n    showPhaseHeader \"$curPhase\";\n    dumpVars;\n    local startTime=$(date +\"%s\");\n    eval \"${!curPhase:-$curPhase}\";\n    local endTime=$(date +\"%s\");\n    showPhaseFooter \"$curPhase\" \"$startTime\" \"$endTime\";\n    if [ \"$curPhase\" = unpackPhase ]; then\n        [ -n \"${sourceRoot:-}\" ] && chmod +x \"${sourceRoot}\";\n        cd \"${sourceRoot:-.}\";\n    fi\n",
    "showPhaseFooter":" \n    local phase=\"$1\";\n    local startTime=\"$2\";\n    local endTime=\"$3\";\n    local delta=$(( endTime - startTime ));\n    (( delta < 30 )) && return;\n    local H=$((delta/3600));\n    local M=$((delta%3600/60));\n    local S=$((delta%60));\n    echo -n \"$phase completed in \";\n    (( H > 0 )) && echo -n \"$H hours \";\n    (( M > 0 )) && echo -n \"$M minutes \";\n    echo \"$S seconds\"\n",
    "showPhaseHeader":" \n    local phase=\"$1\";\n    echo \"Running phase: $phase\"\n",
    "stripDirs":" \n    local cmd=\"$1\";\n    local ranlibCmd=\"$2\";\n    local paths=\"$3\";\n    local stripFlags=\"$4\";\n    local excludeFlags=();\n    local pathsNew=;\n    [ -z \"$cmd\" ] && echo \"stripDirs: Strip command is empty\" 1>&2 && exit 1;\n    [ -z \"$ranlibCmd\" ] && echo \"stripDirs: Ranlib command is empty\" 1>&2 && exit 1;\n    local pattern;\n    if [ -n \"${stripExclude:-}\" ]; then\n        for pattern in \"${stripExclude[@]}\";\n        do\n            excludeFlags+=(-a '!' '(' -name \"$pattern\" -o -wholename \"$prefix/$pattern\" ')');\n        done;\n    fi;\n    local p;\n    for p in ${paths};\n    do\n        if [ -e \"$prefix/$p\" ]; then\n            pathsNew=\"${pathsNew} $prefix/$p\";\n        fi;\n    done;\n    paths=${pathsNew};\n    if [ -n \"${paths}\" ]; then\n        echo \"stripping (with command $cmd and flags $stripFlags) in $paths\";\n        local striperr;\n        striperr=\"$(mktemp --tmpdir=\"$TMPDIR\" 'striperr.XXXXXX')\";\n        find $paths -type f \"${excludeFlags[@]}\" -a '!' -path \"$prefix/lib/debug/*\" -print0 | xargs -r -0 -n1 -- realpath -z | sort -u -z | xargs -r -0 -n1 -P \"$NIX_BUILD_CORES\" -- $cmd $stripFlags 2> \"$striperr\" || exit_code=$?;\n        [[ \"$exit_code\" = 123 || -z \"$exit_code\" ]] || ( cat \"$striperr\" 1>&2 && exit 1 );\n        rm \"$striperr\";\n        find $paths -name '*.a' -type f -exec $ranlibCmd '{}' \\; 2> /dev/null;\n    fi\n",
    "stripHash":" \n    local strippedName casematchOpt=0;\n    strippedName=\"$(basename -- \"$1\")\";\n    shopt -q nocasematch && casematchOpt=1;\n    shopt -u nocasematch;\n    if [[ \"$strippedName\" =~ ^[a-z0-9]{32}- ]]; then\n        echo \"${strippedName:33}\";\n    else\n        echo \"$strippedName\";\n    fi;\n    if (( casematchOpt )); then\n        shopt -s nocasematch;\n    fi\n",
    "substitute":" \n    local input=\"$1\";\n    local output=\"$2\";\n    shift 2;\n    if [ ! -f \"$input\" ]; then\n        echo \"substitute(): ERROR: file '$input' does not exist\" 1>&2;\n        return 1;\n    fi;\n    local content;\n    consumeEntire content < \"$input\";\n    if [ -e \"$output\" ]; then\n        chmod +w \"$output\";\n    fi;\n    substituteStream content \"file '$input'\" \"$@\" > \"$output\"\n",
    "substituteAll":" \n    local input=\"$1\";\n    local output=\"$2\";\n    local -a args=();\n    _allFlags;\n    substitute \"$input\" \"$output\" \"${args[@]}\"\n",
    "substituteAllInPlace":" \n    local fileName=\"$1\";\n    shift;\n    substituteAll \"$fileName\" \"$fileName\" \"$@\"\n",
    "substituteAllStream":" \n    local -a args=();\n    _allFlags;\n    substituteStream \"$1\" \"$2\" \"${args[@]}\"\n",
    "substituteInPlace":" \n    local -a fileNames=();\n    for arg in \"$@\";\n    do\n        if [[ \"$arg\" = \"--\"* ]]; then\n            break;\n        fi;\n        fileNames+=(\"$arg\");\n        shift;\n    done;\n    for file in \"${fileNames[@]}\";\n    do\n        substitute \"$file\" \"$file\" \"$@\";\n    done\n",
    "substituteStream":" \n    local var=$1;\n    local description=$2;\n    shift 2;\n    while (( \"$#\" )); do\n        local replace_mode=\"$1\";\n        case \"$1\" in \n            --replace)\n                if ! \"$_substituteStream_has_warned_replace_deprecation\"; then\n                    echo \"substituteStream(): WARNING: '--replace' is deprecated, use --replace-{fail,warn,quiet}. ($description)\" 1>&2;\n                    _substituteStream_has_warned_replace_deprecation=true;\n                fi;\n                replace_mode='--replace-warn'\n            ;&\n            --replace-quiet | --replace-warn | --replace-fail)\n                pattern=\"$2\";\n                replacement=\"$3\";\n                shift 3;\n                local savedvar;\n                savedvar=\"${!var}\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}';\n                if [ \"$pattern\" != \"$replacement\" ]; then\n                    if [ \"${!var}\" == \"$savedvar\" ]; then\n                        if [ \"$replace_mode\" == --replace-warn ]; then\n                            printf \"substituteStream(): WARNING: pattern %q doesn't match anything in %s\\n\" \"$pattern\" \"$description\" 1>&2;\n                        else\n                            if [ \"$replace_mode\" == --replace-fail ]; then\n                                printf \"substituteStream(): ERROR: pattern %q doesn't match anything in %s\\n\" \"$pattern\" \"$description\" 1>&2;\n                                return 1;\n                            fi;\n                        fi;\n                    fi;\n                fi\n            ;;\n            --subst-var)\n                local varName=\"$2\";\n                shift 2;\n                if ! [[ \"$varName\" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then\n                    echo \"substituteStream(): ERROR: substitution variables must be valid Bash names, \\\"$varName\\\" isn't.\" 1>&2;\n                    return 1;\n                fi;\n                if [ -z ${!varName+x} ]; then\n                    echo \"substituteStream(): ERROR: variable \\$$varName is unset\" 1>&2;\n                    return 1;\n                fi;\n                pattern=\"@$varName@\";\n                replacement=\"${!varName}\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}'\n            ;;\n            --subst-var-by)\n                pattern=\"@$2@\";\n                replacement=\"$3\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}';\n                shift 3\n            ;;\n            *)\n                echo \"substituteStream(): ERROR: Invalid command line argument: $1\" 1>&2;\n                return 1\n            ;;\n        esac;\n    done;\n    printf \"%s\" \"${!var}\"\n",
    "unpackFile":" \n    curSrc=\"$1\";\n    echo \"unpacking source archive $curSrc\";\n    if ! runOneHook unpackCmd \"$curSrc\"; then\n        echo \"do not know how to unpack source archive $curSrc\";\n        exit 1;\n    fi\n",
    "unpackPhase":" \n    runHook preUnpack;\n    if [ -z \"${srcs:-}\" ]; then\n        if [ -z \"${src:-}\" ]; then\n            echo 'variable $src or $srcs should point to the source';\n            exit 1;\n        fi;\n        srcs=\"$src\";\n    fi;\n    local -a srcsArray;\n    if [ -n \"$__structuredAttrs\" ]; then\n        srcsArray=(\"${srcs[@]}\");\n    else\n        srcsArray=($srcs);\n    fi;\n    local dirsBefore=\"\";\n    for i in *;\n    do\n        if [ -d \"$i\" ]; then\n            dirsBefore=\"$dirsBefore $i \";\n        fi;\n    done;\n    for i in \"${srcsArray[@]}\";\n    do\n        unpackFile \"$i\";\n    done;\n    : \"${sourceRoot=}\";\n    if [ -n \"${setSourceRoot:-}\" ]; then\n        runOneHook setSourceRoot;\n    else\n        if [ -z \"$sourceRoot\" ]; then\n            for i in *;\n            do\n                if [ -d \"$i\" ]; then\n                    case $dirsBefore in \n                        *\\ $i\\ *)\n\n                        ;;\n                        *)\n                            if [ -n \"$sourceRoot\" ]; then\n                                echo \"unpacker produced multiple directories\";\n                                exit 1;\n                            fi;\n                            sourceRoot=\"$i\"\n                        ;;\n                    esac;\n                fi;\n            done;\n        fi;\n    fi;\n    if [ -z \"$sourceRoot\" ]; then\n        echo \"unpacker appears to have produced no directories\";\n        exit 1;\n    fi;\n    echo \"source root is $sourceRoot\";\n    if [ \"${dontMakeSourcesWritable:-0}\" != 1 ]; then\n        chmod -R u+w -- \"$sourceRoot\";\n    fi;\n    runHook postUnpack\n",
    "updateAutotoolsGnuConfigScriptsPhase":" \n    if [ -n \"${dontUpdateAutotoolsGnuConfigScripts-}\" ]; then\n        return;\n    fi;\n    for script in config.sub config.guess;\n    do\n        for f in $(find . -type f -name \"$script\");\n        do\n            echo \"Updating Autotools / GNU config script to a newer upstream version: $f\";\n            cp -f \"/nix/store/x1lr71p3jqsy443jz0ravm3fv9yr2x0y-gnu-config-2023-09-19/$script\" \"$f\";\n        done;\n    done\n",
    "updateSourceDateEpoch":" \n    local path=\"$1\";\n    local -a res=($(find \"$path\" -type f -not -newer \"$NIX_BUILD_TOP/..\" -printf '%T@ %p\\0' | sort -n --zero-terminated | tail -n1 --zero-terminated | head -c -1));\n    local time=\"${res[0]//\\.[0-9]*/}\";\n    local newestFile=\"${res[1]}\";\n    if [ \"${time:-0}\" -gt \"$SOURCE_DATE_EPOCH\" ]; then\n        echo \"setting SOURCE_DATE_EPOCH to timestamp $time of file $newestFile\";\n        export SOURCE_DATE_EPOCH=\"$time\";\n        local now=\"$(date +%s)\";\n        if [ \"$time\" -gt $((now - 60)) ]; then\n            echo \"warning: file $newestFile may be generated; SOURCE_DATE_EPOCH may be non-deterministic\";\n        fi;\n    fi\n"
  },
  "variables": {
    "AR": {"type": "exported", "value": "ar"},
    "AS": {"type": "exported", "value": "as"},
    "BASH": {"type": "var", "value": "/nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26/bin/bash"},
    "BASHOPTS": {"type": "unknown"},
    "BASHPID": {"type": "unknown"},
    "CC": {"type": "exported", "value": "gcc"},
    "CONFIG_SHELL": {"type": "exported", "value": "/nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26/bin/bash"},
    "CXX": {"type": "exported", "value": "g++"},
    "HOME": {"type": "exported", "value": "/homeless-shelter"},
    "HOSTTYPE": {"type": "var", "value": "x86_64"},
    "HOST_PATH": {"type": "exported", "value": "/nix/store/fpv9yd0mwm1lyph02j9bdyxbjz8vaxzy-glibc-2.39-5-bin/bin:/nix/store/ifzwv2xqwdnv1gz87rxkizi67py5p3vj-coreutils-9.4/bin:/nix/store/jg2i1qj5js5ckzvfq5b9p9j1gcv69750-findutils-4.9.0/bin:/nix/store/ksyif7fp4p0baafvdm5szd375s7qf6cz-diffutils-3.10/bin:/nix/store/237dff1igc3v09p9r23a37yw8dr04bv6-gnused-4.9/bin:/nix/store/avqi5nnx7qydr078ssgifc2hgzqipqgx-gnugrep-3.11/bin:/nix/store/2s1h0q7xhk33nsw90l0g53bxax0d19ih-gawk-5.2.2/bin:/nix/store/xwvgwr85gghbl66kj30sp19p2y1cypqv-gnutar-1.35/bin:/nix/store/vnfi66rm1dykn8gwwy5i4f48bhbk9x6x-gzip-1.13/bin:/nix/store/3bdjxil2cz8dkd6l5sf4qalla762m99d-bzip2-1.0.8-bin/bin:/nix/store/pg3wkw0as88676ib4ckbibrfwy5c5vzg-gnumake-4.4.1/bin:/nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26/bin:/nix/store/bf9rz7vvxannxp15wfi7x0bx5b68ky7z-patch-2.7.6/bin:/nix/store/jdg5lv2j7d765h8pn73qz72lilxrcb5x-xz-5.4.6-bin/bin:/nix/store/j3f0hag67n4piz2avqgf07gja8a2ifn6-file-5.45/bin"},
    "IFS": {"type": "var", "value": " \t\n"},
    "IN_NIX_SHELL": {"type": "exported", "value": "impure"},
    "LD": {"type": "exported", "value": "ld"},
    "LINENO": {"type": "var", "value": "76"},
    "MACHTYPE": {"type": "var", "value": "x86_64-pc-linux-gnu"},
    "NIX_BINTOOLS": {"type": "exported", "value": "/nix/store/jsjfmx7r6cpyixxsg7bjl5cy3y8hw7k7-binutils-wrapper-2.41"},
    "NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu": {"type": "exported", "value": "1"},
    "NIX_BUILD_CORES": {"type": "exported", "value": "28"},
    "NIX_BUILD_TOP": {"type": "exported", "value": "/build"},
    "NIX_CC": {"type": "exported", "value": "/nix/store/ac1hb5dc2z4biwgy8mjrhlifffkkrvdq-gcc-wrapper-13.2.0"},
    "NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu": {"type": "exported", "value": "1"},
    "NIX_CFLAGS_COMPILE": {"type": "exported", "value": " -frandom-seed=qbliaava2j -isystem /nix/store/2b3cy4nlnb6wb6y6yrfrmc1lmjx20jsq-musl-1.2.3-dev/include -isystem /nix/store/gzxqm8dyfirbysqjhh78ivam62ll0m87-glibc-2.39-5-dev/include -isystem /nix/store/2b3cy4nlnb6wb6y6yrfrmc1lmjx20jsq-musl-1.2.3-dev/include -isystem /nix/store/gzxqm8dyfirbysqjhh78ivam62ll0m87-glibc-2.39-5-dev/include"},
    "NIX_ENFORCE_NO_NATIVE": {"type": "exported", "value": "1"},
    "NIX_ENFORCE_PURITY": {"type": "exported", "value": "1"},
    "NIX_HARDENING_ENABLE": {"type": "exported", "value": "bindnow format fortify fortify3 pic relro stackprotector strictoverflow"},
    "NIX_LDFLAGS": {"type": "exported", "value": "-rpath /nix/store/qbliaava2jj6qikrhhnpxbqvvvjq3xsk-pwn-with-c-env/lib  -L/nix/store/8m8jkm712pjms96xwliidad77rk7r7f4-musl-1.2.3/lib -L/nix/store/ddwyrxif62r8n6xclvskjyy6szdhvj60-glibc-2.39-5/lib -L/nix/store/b2z593kkib70i6j57l92c3x666baaknc-glibc-2.39-5-static/lib -L/nix/store/8m8jkm712pjms96xwliidad77rk7r7f4-musl-1.2.3/lib -L/nix/store/ddwyrxif62r8n6xclvskjyy6szdhvj60-glibc-2.39-5/lib -L/nix/store/b2z593kkib70i6j57l92c3x666baaknc-glibc-2.39-5-static/lib"},
    "NIX_LOG_FD": {"type": "exported", "value": "2"},
    "NIX_NO_SELF_RPATH": {"type": "var", "value": "1"},
    "NIX_STORE": {"type": "exported", "value": "/nix/store"},
    "NM": {"type": "exported", "value": "nm"},
    "OBJCOPY": {"type": "exported", "value": "objcopy"},
    "OBJDUMP": {"type": "exported", "value": "objdump"},
    "OLDPWD": {"type": "exported", "value": ""},
    "OPTERR": {"type": "var", "value": "1"},
    "OPTIND": {"type": "unknown"},
    "OSTYPE": {"type": "var", "value": "linux-gnu"},
    "PATH": {"type": "exported", "value": "/nix/store/2b3cy4nlnb6wb6y6yrfrmc1lmjx20jsq-musl-1.2.3-dev/bin:/nix/store/a3wznn2ahazybzdscgjxzqf5b5mgdfz9-musl-1.2.3-bin/bin:/nix/store/43n2dxi419b1jgv2bq1xg7y6n8k66xpb-patchelf-0.15.0/bin:/nix/store/ac1hb5dc2z4biwgy8mjrhlifffkkrvdq-gcc-wrapper-13.2.0/bin:/nix/store/a3mmr5jmrd0sjvmnc9vqvs388ppq1bnf-gcc-13.2.0/bin:/nix/store/fpv9yd0mwm1lyph02j9bdyxbjz8vaxzy-glibc-2.39-5-bin/bin:/nix/store/ifzwv2xqwdnv1gz87rxkizi67py5p3vj-coreutils-9.4/bin:/nix/store/jsjfmx7r6cpyixxsg7bjl5cy3y8hw7k7-binutils-wrapper-2.41/bin:/nix/store/hqvni28zpibl6jsqqimcvng6h6qm58xy-binutils-2.41/bin:/nix/store/ifzwv2xqwdnv1gz87rxkizi67py5p3vj-coreutils-9.4/bin:/nix/store/jg2i1qj5js5ckzvfq5b9p9j1gcv69750-findutils-4.9.0/bin:/nix/store/ksyif7fp4p0baafvdm5szd375s7qf6cz-diffutils-3.10/bin:/nix/store/237dff1igc3v09p9r23a37yw8dr04bv6-gnused-4.9/bin:/nix/store/avqi5nnx7qydr078ssgifc2hgzqipqgx-gnugrep-3.11/bin:/nix/store/2s1h0q7xhk33nsw90l0g53bxax0d19ih-gawk-5.2.2/bin:/nix/store/xwvgwr85gghbl66kj30sp19p2y1cypqv-gnutar-1.35/bin:/nix/store/vnfi66rm1dykn8gwwy5i4f48bhbk9x6x-gzip-1.13/bin:/nix/store/3bdjxil2cz8dkd6l5sf4qalla762m99d-bzip2-1.0.8-bin/bin:/nix/store/pg3wkw0as88676ib4ckbibrfwy5c5vzg-gnumake-4.4.1/bin:/nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26/bin:/nix/store/bf9rz7vvxannxp15wfi7x0bx5b68ky7z-patch-2.7.6/bin:/nix/store/jdg5lv2j7d765h8pn73qz72lilxrcb5x-xz-5.4.6-bin/bin:/nix/store/j3f0hag67n4piz2avqgf07gja8a2ifn6-file-5.45/bin"},
    "PS4": {"type": "var", "value": "+ "},
    "RANLIB": {"type": "exported", "value": "ranlib"},
    "READELF": {"type": "exported", "value": "readelf"},
    "SHELL": {"type": "exported", "value": "/nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26/bin/bash"},
    "SHELLOPTS": {"type": "unknown"},
    "SIZE": {"type": "exported", "value": "size"},
    "SOURCE_DATE_EPOCH": {"type": "exported", "value": "315532800"},
    "SRANDOM": {"type": "unknown"},
    "STRINGS": {"type": "exported", "value": "strings"},
    "STRIP": {"type": "exported", "value": "strip"},
    "TEMP": {"type": "exported", "value": "/build"},
    "TEMPDIR": {"type": "exported", "value": "/build"},
    "TERM": {"type": "exported", "value": "xterm-256color"},
    "TMP": {"type": "exported", "value": "/build"},
    "TMPDIR": {"type": "exported", "value": "/build"},
    "TZ": {"type": "exported", "value": "UTC"},
    "XDG_DATA_DIRS": {"type": "exported", "value": "/nix/store/43n2dxi419b1jgv2bq1xg7y6n8k66xpb-patchelf-0.15.0/share"},
    "__structuredAttrs": {"type": "exported", "value": ""},
    "_substituteStream_has_warned_replace_deprecation": {"type": "var", "value": "false"},
    "buildInputs": {"type": "exported", "value": "/nix/store/gzxqm8dyfirbysqjhh78ivam62ll0m87-glibc-2.39-5-dev /nix/store/b2z593kkib70i6j57l92c3x666baaknc-glibc-2.39-5-static"},
    "buildPhase": {"type": "exported", "value": "gcc -static -masm=intel exp.c -L/nix/store/b6aiqvxcg0b2z7jkay7xhm65a7gv2zfv-libLian/lib -lLian -I/nix/store/b6aiqvxcg0b2z7jkay7xhm65a7gv2zfv-libLian/include -o exp\n"},
    "builder": {"type": "exported", "value": "/nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26/bin/bash"},
    "cmakeFlags": {"type": "exported", "value": ""},
    "configureFlags": {"type": "exported", "value": ""},
    "defaultBuildInputs": {"type": "var", "value": ""},
    "defaultNativeBuildInputs": {"type": "var", "value": "/nix/store/43n2dxi419b1jgv2bq1xg7y6n8k66xpb-patchelf-0.15.0 /nix/store/9la7flpks9z89djvmmblzzs4fqvhwgzg-update-autotools-gnu-config-scripts-hook /nix/store/h9lc1dpi14z7is86ffhl3ld569138595-audit-tmpdir.sh /nix/store/m54bmrhj6fqz8nds5zcj97w9s9bckc9v-compress-man-pages.sh /nix/store/wgrbkkaldkrlrni33ccvm3b6vbxzb656-make-symlinks-relative.sh /nix/store/5yzw0vhkyszf2d179m0qfkgxmp5wjjx4-move-docs.sh /nix/store/fyaryjvghbkpfnsyw97hb3lyb37s1pd6-move-lib64.sh /nix/store/kd4xwxjpjxi71jkm6ka0np72if9rm3y0-move-sbin.sh /nix/store/pag6l61paj1dc9sv15l7bm5c17xn5kyk-move-systemd-user-units.sh /nix/store/jivxp510zxakaaic7qkrb7v1dd2rdbw9-multiple-outputs.sh /nix/store/ilaf1w22bxi6jsi45alhmvvdgy4ly3zs-patch-shebangs.sh /nix/store/cickvswrvann041nqxb0rxilc46svw1n-prune-libtool-files.sh /nix/store/xyff06pkhki3qy1ls77w10s0v79c9il0-reproducible-builds.sh /nix/store/ngg1cv31c8c7bcm2n8ww4g06nq7s4zhm-set-source-date-epoch-to-latest.sh /nix/store/wmknncrif06fqxa16hpdldhixk95nds0-strip.sh /nix/store/ac1hb5dc2z4biwgy8mjrhlifffkkrvdq-gcc-wrapper-13.2.0"},
    "depsBuildBuild": {"type": "exported", "value": ""},
    "depsBuildBuildPropagated": {"type": "exported", "value": ""},
    "depsBuildTarget": {"type": "exported", "value": ""},
    "depsBuildTargetPropagated": {"type": "exported", "value": ""},
    "depsHostHost": {"type": "exported", "value": ""},
    "depsHostHostPropagated": {"type": "exported", "value": ""},
    "depsTargetTarget": {"type": "exported", "value": ""},
    "depsTargetTargetPropagated": {"type": "exported", "value": ""},
    "doCheck": {"type": "exported", "value": ""},
    "doInstallCheck": {"type": "exported", "value": ""},
    "dontAddDisableDepTrack": {"type": "exported", "value": "1"},
    "envBuildBuildHooks": {"type": "array", "value": []},
    "envBuildHostHooks": {"type": "array", "value": []},
    "envBuildTargetHooks": {"type": "array", "value": []},
    "envHostHostHooks": {"type": "array", "value": ["ccWrapper_addCVars" , "bintoolsWrapper_addLDVars" ]},
    "envHostTargetHooks": {"type": "array", "value": ["ccWrapper_addCVars" , "bintoolsWrapper_addLDVars" ]},
    "envTargetTargetHooks": {"type": "array", "value": []},
    "fixupOutputHooks": {"type": "array", "value": ["if [ -z \"${dontPatchELF-}\" ]; then patchELF \"$prefix\"; fi" , "if [[ -z \"${noAuditTmpdir-}\" && -e \"$prefix\" ]]; then auditTmpdir \"$prefix\"; fi" , "if [ -z \"${dontGzipMan-}\" ]; then compressManPages \"$prefix\"; fi" , "_moveLib64" , "_moveSbin" , "_moveSystemdUserUnits" , "patchShebangsAuto" , "_pruneLibtoolFiles" , "_doStrip" ]},
    "guess": {"type": "var", "value": "28"},
    "initialPath": {"type": "var", "value": "/nix/store/ifzwv2xqwdnv1gz87rxkizi67py5p3vj-coreutils-9.4 /nix/store/jg2i1qj5js5ckzvfq5b9p9j1gcv69750-findutils-4.9.0 /nix/store/ksyif7fp4p0baafvdm5szd375s7qf6cz-diffutils-3.10 /nix/store/237dff1igc3v09p9r23a37yw8dr04bv6-gnused-4.9 /nix/store/avqi5nnx7qydr078ssgifc2hgzqipqgx-gnugrep-3.11 /nix/store/2s1h0q7xhk33nsw90l0g53bxax0d19ih-gawk-5.2.2 /nix/store/xwvgwr85gghbl66kj30sp19p2y1cypqv-gnutar-1.35 /nix/store/vnfi66rm1dykn8gwwy5i4f48bhbk9x6x-gzip-1.13 /nix/store/3bdjxil2cz8dkd6l5sf4qalla762m99d-bzip2-1.0.8-bin /nix/store/pg3wkw0as88676ib4ckbibrfwy5c5vzg-gnumake-4.4.1 /nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26 /nix/store/bf9rz7vvxannxp15wfi7x0bx5b68ky7z-patch-2.7.6 /nix/store/jdg5lv2j7d765h8pn73qz72lilxrcb5x-xz-5.4.6-bin /nix/store/j3f0hag67n4piz2avqgf07gja8a2ifn6-file-5.45"},
    "installPhase": {"type": "exported", "value": "mkdir -p $out/bin\ncp test $out/bin/\n"},
    "mesonFlags": {"type": "exported", "value": ""},
    "name": {"type": "exported", "value": "pwn-with-c-env"},
    "nativeBuildInputs": {"type": "exported", "value": "/nix/store/2b3cy4nlnb6wb6y6yrfrmc1lmjx20jsq-musl-1.2.3-dev"},
    "out": {"type": "exported", "value": "/nix/store/qbliaava2jj6qikrhhnpxbqvvvjq3xsk-pwn-with-c-env"},
    "outputBin": {"type": "var", "value": "out"},
    "outputDev": {"type": "var", "value": "out"},
    "outputDevdoc": {"type": "var", "value": "REMOVE"},
    "outputDevman": {"type": "var", "value": "out"},
    "outputDoc": {"type": "var", "value": "out"},
    "outputInclude": {"type": "var", "value": "out"},
    "outputInfo": {"type": "var", "value": "out"},
    "outputLib": {"type": "var", "value": "out"},
    "outputMan": {"type": "var", "value": "out"},
    "outputs": {"type": "exported", "value": "out"},
    "patches": {"type": "exported", "value": ""},
    "pkg": {"type": "var", "value": "/nix/store/ac1hb5dc2z4biwgy8mjrhlifffkkrvdq-gcc-wrapper-13.2.0"},
    "pkgsBuildBuild": {"type": "array", "value": []},
    "pkgsBuildHost": {"type": "array", "value": ["/nix/store/2b3cy4nlnb6wb6y6yrfrmc1lmjx20jsq-musl-1.2.3-dev" , "/nix/store/a3wznn2ahazybzdscgjxzqf5b5mgdfz9-musl-1.2.3-bin" , "/nix/store/8m8jkm712pjms96xwliidad77rk7r7f4-musl-1.2.3" , "/nix/store/43n2dxi419b1jgv2bq1xg7y6n8k66xpb-patchelf-0.15.0" , "/nix/store/9la7flpks9z89djvmmblzzs4fqvhwgzg-update-autotools-gnu-config-scripts-hook" , "/nix/store/h9lc1dpi14z7is86ffhl3ld569138595-audit-tmpdir.sh" , "/nix/store/m54bmrhj6fqz8nds5zcj97w9s9bckc9v-compress-man-pages.sh" , "/nix/store/wgrbkkaldkrlrni33ccvm3b6vbxzb656-make-symlinks-relative.sh" , "/nix/store/5yzw0vhkyszf2d179m0qfkgxmp5wjjx4-move-docs.sh" , "/nix/store/fyaryjvghbkpfnsyw97hb3lyb37s1pd6-move-lib64.sh" , "/nix/store/kd4xwxjpjxi71jkm6ka0np72if9rm3y0-move-sbin.sh" , "/nix/store/pag6l61paj1dc9sv15l7bm5c17xn5kyk-move-systemd-user-units.sh" , "/nix/store/jivxp510zxakaaic7qkrb7v1dd2rdbw9-multiple-outputs.sh" , "/nix/store/ilaf1w22bxi6jsi45alhmvvdgy4ly3zs-patch-shebangs.sh" , "/nix/store/cickvswrvann041nqxb0rxilc46svw1n-prune-libtool-files.sh" , "/nix/store/xyff06pkhki3qy1ls77w10s0v79c9il0-reproducible-builds.sh" , "/nix/store/ngg1cv31c8c7bcm2n8ww4g06nq7s4zhm-set-source-date-epoch-to-latest.sh" , "/nix/store/wmknncrif06fqxa16hpdldhixk95nds0-strip.sh" , "/nix/store/ac1hb5dc2z4biwgy8mjrhlifffkkrvdq-gcc-wrapper-13.2.0" , "/nix/store/jsjfmx7r6cpyixxsg7bjl5cy3y8hw7k7-binutils-wrapper-2.41" ]},
    "pkgsBuildTarget": {"type": "array", "value": []},
    "pkgsHostHost": {"type": "array", "value": []},
    "pkgsHostTarget": {"type": "array", "value": ["/nix/store/gzxqm8dyfirbysqjhh78ivam62ll0m87-glibc-2.39-5-dev" , "/nix/store/fpv9yd0mwm1lyph02j9bdyxbjz8vaxzy-glibc-2.39-5-bin" , "/nix/store/ddwyrxif62r8n6xclvskjyy6szdhvj60-glibc-2.39-5" , "/nix/store/b2z593kkib70i6j57l92c3x666baaknc-glibc-2.39-5-static" ]},
    "pkgsTargetTarget": {"type": "array", "value": []},
    "postFixupHooks": {"type": "array", "value": ["_makeSymlinksRelativeInAllOutputs" , "_multioutPropagateDev" ]},
    "postUnpackHooks": {"type": "array", "value": ["_updateSourceDateEpochFromSourceRoot" ]},
    "preConfigureHooks": {"type": "array", "value": ["_multioutConfig" ]},
    "preConfigurePhases": {"type": "var", "value": " updateAutotoolsGnuConfigScriptsPhase"},
    "preFixupHooks": {"type": "array", "value": ["_moveToShare" , "_multioutDocs" , "_multioutDevs" ]},
    "prefix": {"type": "var", "value": "/nix/store/qbliaava2jj6qikrhhnpxbqvvvjq3xsk-pwn-with-c-env"},
    "propagatedBuildDepFiles": {"type": "array", "value": ["propagated-build-build-deps" , "propagated-native-build-inputs" , "propagated-build-target-deps" ]},
    "propagatedBuildInputs": {"type": "exported", "value": ""},
    "propagatedHostDepFiles": {"type": "array", "value": ["propagated-host-host-deps" , "propagated-build-inputs" ]},
    "propagatedNativeBuildInputs": {"type": "exported", "value": ""},
    "propagatedTargetDepFiles": {"type": "array", "value": ["propagated-target-target-deps" ]},
    "shell": {"type": "exported", "value": "/nix/store/a1s263pmsci9zykm5xcdf7x9rv26w6d5-bash-5.2p26/bin/bash"},
    "src": {"type": "exported", "value": "/nix/store/fvhd4kh6plcy5fv2p8dnr8865md1ywi3-libLian"},
    "stdenv": {"type": "exported", "value": "/nix/store/v5lsd029lz5lfhamivbgqyp3zdv94ah2-stdenv-linux"},
    "strictDeps": {"type": "exported", "value": ""},
    "system": {"type": "exported", "value": "x86_64-linux"},
    "unpackCmdHooks": {"type": "array", "value": ["_defaultUnpack" ]}
  }
}