---
date: 2024-07-20 08:18
challenge: pwn1
tags:
  - small bof
---

## pwn1

这道题有一些东拼西凑的感觉，有趣的点在于栈上溢出的数量非常有限，只能改写到返回地址，同时 gadget 也很少，没有控制 rsi、rdx 的能力。

最初考虑：程序开始的时候读了一些东西到 .bss 段上，那就栈迁移过去让 ROP 链接上，但是发现栈迁移过去后 puts 函数无法正常调用 - 因为栈太浅了，这条路也就断了。

> [!NOTE]
> 在公司里没有 ida，愣是花了半天才发现存在一个 `magic_gadget`，主要是两个功能：
>
> 1. 造成栈错位的现象，最终 rbp 位于栈顶 rsp 上面
> 2. 最后返回到一开始设置好的 rbp 地址

上述能力提供了获取输入时修改下个被调用函数（这里是 read）返回地址的能力，因此就可以构造更长的 ROP 链。

最后还要在堆上找到 flag 内容，这里考虑 libc 中 `mp_` 的 `sbrk_base` 域，会指向堆地址的开头：

[exp.py](./exp.py)
