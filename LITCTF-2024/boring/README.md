---
date: 2024-08-13 13:15
challenge: How to Raise a Boring Vuln
tags:
  - scanf
  - qsort
---

不得不感叹 qsort 这个函数真是很适合出现在 CTF 中：不仅有着自定义的比较函数，其中还在 length 超过 0x100 的情况下会用 malloc 出来的缓冲区完成比较并在 return 前释放。

题目的难点在于泄露，首先众所周知 scanf 如果如果没有扫描到合法字符也不会刷新缓冲区，而是会影响接下来的 scanf 操作。

~~但是这道题目中可以用 `\x00\n` 来绕过，使 `scanf("%d")` 不影响缓冲区内原本的值，使得通过堆块上残留地址完成泄露成为可能。~~

**scanf 实际上可以用加号 `+` 来绕过，被 gpt 骗了**

但是还有第二个问题，qsort free 后的堆块是紧挨着 top chunk 的，如果不能用其它堆块隔开，也无法获得 libc 地址。

解决方案是使用 main 函数作为比较函数，在其中再进行堆块申请，于是这块超过 0x100 \* 4 的堆块就有机会被放入 unsorted bin 并存有 libc 地址，这也导致了我的 exp 要调用超过 0x400 次 main 函数完成泄露。

得到 libc 地址后只需要把 system 地址写到待比较数组中，让 qsort 把它放到栈上就可以了。需要注意的是这里不能使用比较函数，不然高低 32 比特会分开存储，因此继续使用 main 函数作为比较函数：

[exp.py](./exp.py)
